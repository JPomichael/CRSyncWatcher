<#
// LinqConnect template for Devart Entity Developer C# code generation.
// Copyright (c) 2008-2014 Devart. All rights reserved.
#>
<#@ template language="C#" #>
<#@ include file="Validation.tmpl" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="EntityDeveloper.Mapping" #>
<#@ property name="FilePerClass" category="Output" type="System.Boolean" description="If it is set to True, each model class will be placed to the separate file when generating code, otherwise, all model classes will be placed into a single file." #>
<#@ property name="ModelNameAsFilesPrefix" category="Output" type="System.Boolean" default="True" description="If it is set to True, then the main model file name will be used as a prefix for the names of the files generated for entities. The property can be used, if File Per Class is turned on." #>
<#@ property name="HeaderTimestampVersionControlTag" category="Generation" type="System.String" description="If this option is set, the standard date/time-stamp in the file header will be replaced with the specified tag (e.g. a version control tag for Subversion, Git, etc.)" #>
<#@ property name="EntitiesOutput" category="Output" type="OutputInfo" editor="OutputInfoEditor" description="Specifies output for the generated entity classes. The property can be used, if File Per Class is turned on." #>
<#@ property name="ContextOutput" category="Output" type="OutputInfo" editor="OutputInfoEditor" description="Specifies output for the generated context." #>
<#@ property name="GeneratePartialClass" category="Output" type="System.Boolean" default="False" description="If it is set to True, then, for each class in the model, a partial class (%ModelName%.%ClassName%.cs) will be generated, in which the user can add code that is not overwritten by the designer. If %ModelName%.%ClassName%.cs was created before, it would be left unchanged. The property can be used, if File Per Class is turned on." #>
<#@ extended name="EntityBase" owner="Class" type="System.String" description="Base class or interface for the entity class." #>
<#@ property name="ImplementCloneable" category="Generation" type="System.Boolean" description="If it is set to True, each entity class will implement the ICloneable interface." #>
<#@ property name="UseCompiledQueryCache" category="Generation" type="System.Boolean" default="True" description="If it is set to True, the context model class will be registered in CompiledQueryCache." #>
<#@ property name="GenerateDummyComments" category="Generation" type="System.Boolean" default="False" description="If it is set to True, then dummy xml §ãomments will be generated for each publicly visible type or member." #>
<#
  // Settings
  output.Extension = ".cs";
  baseFileName = model.FileName;

  // Begin generation

  //------------------------------------------------------------------------------
  // DataContext class generation
  //------------------------------------------------------------------------------

  string contextClassName = model.Name;
  string contextNamespace = !string.IsNullOrEmpty(model.ContextNamespace) ? codeProvider.GetValidIdentifier(model.ContextNamespace) : codeProvider.GetValidIdentifier(model.Name);
  string namespaceName = !string.IsNullOrEmpty(model.EntityNamespace) ? codeProvider.GetValidIdentifier(model.EntityNamespace) : codeProvider.GetValidIdentifier(model.Name);

  string dataContextFileName;
  if (FilePerClass)
    dataContextFileName = baseFileName + "." + contextClassName;
  else
    dataContextFileName = baseFileName + ".Designer";

  output.PushOutputRedirection(ContextOutput, dataContextFileName);

  GenerateContextFileHeader();

  if (model.Settings.TargetFramework == TargetFramework.WinPhone) {
#>
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Devart.Data.Linq")]
<#
  }
  else 
    if (model.Settings.TargetFramework == TargetFramework.Silverlight) {
#>
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("System.Core, PublicKey=00240000048000009400000006020000002400005253413100040000010001008d56c76f9e8649383049f383c44be0ec204181822a6c31cf5eb7ef486944d032188ea1d3920763712ccb12d75fb77e9811149e6148e5d32fbaab37611c1878ddc19e20ef135d0cb2cff2bfec3d115810c3d9069638fe4be215dbf795861920e5ab6f7db2e2ceef136ac23d5dd2bf031700aec232f6c6b1c785b4305c123b37ab")]
[assembly: System.Runtime.CompilerServices.InternalsVisibleTo("Devart.Data.Linq, PublicKey=0024000004800000940000000602000000240000525341310004000001000100F9CD19E29F7E13B226CCB194466620ED74DBF90F8D8756B2B1A1F26A3191F64B41F6AB438D7DB747BC1386435B9616362E1606181F35E23C56802FA1E36549648538CB199759E08A996D6C07C0913E0064B60893D5126AC0B8926FB5CE226BB4D18EE389F7428C5E096E82AC879C83CF5010D7F5CF120B6D48FECBA56ED7E0BC")]
<#
    }
#>

namespace <#= contextNamespace #>
{

<#
      if (GenerateDummyComments) {
#>
    /// <summary>
    /// There are no comments for <#= contextClassName #> class in the schema.
    /// </summary>
<#
      }
#>
<#
  if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) {
#>
    [DatabaseAttribute(Name = "<#= model.Database #>")]
<#
    if (!string.IsNullOrEmpty(model.RuntimeProviderName)) {
#>
    [ProviderAttribute(typeof(<#= model.RuntimeProviderName #>))]
<#
    }
  }

  string inheritanceModifier = model.InheritanceModifier == ClassInheritanceModifier.None ? "" : " " + codeProvider.FormatClassInheritanceModifier(model.InheritanceModifier);

  foreach(AttributeValue attribute in model.Attributes) {
    output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);     
#>
    <#= codeProvider.FormatAttributeValue(attribute) #>
<#
  }
#>
    <#= codeProvider.FormatClassAccess(model.Access) #><#= inheritanceModifier #> partial class <#= contextClassName #> : <#= model.BaseClass #>
    {
<#
  if (UseCompiledQueryCache) {
#>
<#
      if (GenerateDummyComments) {
#>
    
        /// <summary>
        /// There are no comments for compiledQueryCache property in the schema.
        /// </summary>
<#
      }
#>
        public static CompiledQueryCache compiledQueryCache = CompiledQueryCache.RegisterDataContext(typeof(<#= contextClassName #>));
<#
  }
  if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) {
#>
        private static MappingSource mappingSource = new Devart.Data.Linq.Mapping.AttributeMappingSource();
<#
  }
  else {
    string resName = model.FileName + ".xml";
    if (!string.IsNullOrEmpty(ContextOutput.ProjectFolder))
      resName = ContextOutput.ProjectFolder.Replace(@"\", ".") + "." + resName;
#>

        private class DefaultXmlMappingProvider
        {
            private static MappingSource defaultSource;

            static DefaultXmlMappingProvider()
            {
                defaultSource = XmlMappingSource.FromResource(@"<#= resName  #>");
            }

            internal static MappingSource DefaultSource
            {
                get
                {
                    return defaultSource; 
                }
            }
        }
<#
  }
#>

        #region Extensibility Method Definitions
    
<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for OnCreated method in the schema.
        /// </summary>
<#
      }
#>
        partial void OnCreated();
<#
      if (GenerateDummyComments) {
#>

        /// <summary>
        /// There are no comments for OnSubmitError method in the schema.
        /// </summary>
<#
      }
#>
        partial void OnSubmitError(Devart.Data.Linq.SubmitErrorEventArgs args);
<#
  GenerateContextUpdatesMethods(); 
#>

        #endregion
<#
  GenerateContextConstructors(); 
  GenerateContextObjectServices();

  // class behavior method mappings of context
  foreach (LinqClass cls in model.Classes) {
   if (!string.IsNullOrEmpty(cls.Source)) {
     GenerateContextUpdateClassMethod(cls.InsertMethodMapping, "Insert");
     GenerateContextUpdateClassMethod(cls.UpdateMethodMapping, "Update");
     GenerateContextUpdateClassMethod(cls.DeleteMethodMapping, "Delete");
   }
  }
  GenerateContextMethods();
#>
    }
<#
  // End of DataContext generation.
#>
}
<#

  //------------------------------------------------------------------------------
  // Class generation for entities
  //------------------------------------------------------------------------------
  var namespaces = from cls in model.Classes.Cast<Class>()
    let nspName = !String.IsNullOrEmpty(cls.Namespace) ? codeProvider.GetValidIdentifier(cls.Namespace) : namespaceName
    group cls by nspName;

  foreach (var _namespace in namespaces) {
    if (!FilePerClass) {
#>

namespace <#= _namespace.Key #>
{
<#
    }
    foreach (LinqClass cls in _namespace) {
      if (FilePerClass) {
        string rootFileName = ModelNameAsFilesPrefix ? baseFileName + "." + cls.Name : cls.Name;
        if (GeneratePartialClass) {
          output.Extension = ".cs";
          output.PushOutputRedirection(EntitiesOutput, "", rootFileName, OverwriteMode.None);
          GenerateFileHeader(false);
#>

namespace <#= _namespace.Key #>
{

    <#= codeProvider.FormatClassAccess(cls.Access) #> partial class <#= codeProvider.GetValidIdentifier(cls.Name) #>
    {
    }
}
<#
          output.PopOutputRedirection();
        }

        output.Extension = ".cs";
        if (GeneratePartialClass)
          output.PushOutputRedirection(EntitiesOutput, rootFileName, rootFileName + ".Generated");
        else
          output.PushOutputRedirection(EntitiesOutput, rootFileName);
        GenerateFileHeader(true);
#>

namespace <#= _namespace.Key #>
{
<#
    }

    int propertyCounter = 0;
    string baseList = "";
    bool hasPrimaryKey = cls.AllProperties.Any(p => p.PrimaryKey);
    bool implementPropertyChanging = cls.BaseInheritance == null && hasPrimaryKey;
    if (cls.BaseInheritance != null) {
      if (cls.BaseInheritance.BaseClass.NamespaceUsed != _namespace.Key)
          baseList = codeProvider.GetValidIdentifier(cls.BaseInheritance.BaseClass.NamespaceUsed) + ".";
      baseList += codeProvider.GetValidIdentifier(cls.BaseInheritance.BaseClass.Name);
    }
    else {
      if (implementPropertyChanging)
        baseList = "INotifyPropertyChanging, INotifyPropertyChanged";
      
        string entityBase = cls.GetProperty("EntityBase") as string;
        if (string.IsNullOrEmpty(entityBase))
           entityBase = model.EntityBase;
        if (!string.IsNullOrEmpty(entityBase) && entityBase != Class.NoneType)
          baseList = string.IsNullOrEmpty(baseList) ? entityBase : entityBase + ", " + baseList;

      // ICloneable
      if (ImplementCloneable)
        baseList = string.IsNullOrEmpty(baseList) ? "ICloneable" : baseList + ", ICloneable";
    }

    GenerateDocumentation(cls.Documentation, cls.FullName); 

    if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) {
      if (!string.IsNullOrEmpty(cls.Source) && (cls.BaseInheritance == null || (cls.BaseInheritance != null && cls.BaseInheritance.Type == InheritanceType.TPT) )) {
#>
    [Table(Name = @"<#= codeProvider.GetQuotedString(cls.Source) #>")]
<#
      }

      if (cls.BaseInheritance == null) {

      // InheritanceMapping attributes for root base class
        if (cls.DerivedInheritances.Count > 0) {

          // for TPH inheritance
          foreach (LinqInheritance derivedInheritance in cls.DerivedInheritances) {
            if (derivedInheritance.Type == InheritanceType.TPH && derivedInheritance.BaseClassDiscriminatorValue != null) {
#>
    [InheritanceMapping(Code="<#= derivedInheritance.BaseClassDiscriminatorValue #>", Type=typeof(<#= codeProvider.GetValidIdentifier(cls.Name) #>)<# if (derivedInheritance.InheritanceDefault != null && cls.Name == derivedInheritance.InheritanceDefault.Name) { #>, IsDefault=true<# } #>)]
<#            break;
            }
          }

          // InheritanceMapping attributes for all child inheritances
          foreach (LinqInheritance inheritance in cls.ChildInheritances) {
            string derivedClass = string.Empty; 
            if (inheritance.DerivedClass.NamespaceUsed != _namespace.Key)
              derivedClass = codeProvider.GetValidIdentifier(inheritance.DerivedClass.NamespaceUsed) + ".";
            derivedClass += codeProvider.GetValidIdentifier(inheritance.DerivedClass.Name);
            if (inheritance.Type == InheritanceType.TPH) {
              if (inheritance.DerivedClassDiscriminatorValue != null) {
#>
    [InheritanceMapping(Code="<#= inheritance.DerivedClassDiscriminatorValue #>", Type=typeof(<#= derivedClass #>)<# if (inheritance.DerivedClass == inheritance.InheritanceDefault) { #>, IsDefault=true<# } #>)]
<#            }
            }
            else {
#>
    [InheritanceMapping(Type=typeof(<#= derivedClass #>))]
<#          }
          }
        }
      } 
      else {
          if (cls.BaseInheritance.Type == InheritanceType.TPT) {
            foreach (InheritanceColumnMapping tptColumnMapping in ((LinqConnectInheritance)cls.BaseInheritance).TPTColumnMappings) {
              if (!string.IsNullOrEmpty(tptColumnMapping.BaseJoinProperty.Source) && !string.IsNullOrEmpty(tptColumnMapping.ThisJoinColumn)) {
#>
    [Devart.Data.Linq.Mapping.InheritanceColumnMapping(BaseColumnName = @"<#= codeProvider.GetQuotedString(tptColumnMapping.BaseJoinProperty.Source) #>", ThisColumnName = @"<#= codeProvider.GetQuotedString(tptColumnMapping.ThisJoinColumn) #>")]
<#            }
            }
          }
      }
    }
    if (model.SerializationMode != LinqSerializationMode.None) {
#>
    [DataContract(IsReference = true)]
<#
    }

    inheritanceModifier = cls.InheritanceModifier == ClassInheritanceModifier.None ? "" : " " + codeProvider.FormatClassInheritanceModifier(cls.InheritanceModifier);

    foreach(AttributeValue attribute in cls.Attributes) {
      output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);     
#>
    <#= codeProvider.FormatAttributeValue(attribute) #>
<#
    }
#>
    <#= codeProvider.FormatClassAccess(cls.Access) #><#= inheritanceModifier #> partial class <#= codeProvider.GetValidIdentifier(cls.Name) #><# if (!string.IsNullOrEmpty(baseList)) { #> : <#= baseList #><# } #>

    {
<#
    // PropertyChangingEventArgs emptyChangingEventArgs
    if (implementPropertyChanging) {
#>

        private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(System.String.Empty);
<#
    }
#>
        #pragma warning disable 0649
<#

    // Class fields
    foreach (LinqProperty property in cls.Properties) {
      string propertyDataType = string.Empty;
      if (property.IsComplexType) {
        propertyDataType = GetPropertyType(property);
      }
      else
        propertyDataType = property.DelayLoaded ? string.Format("Devart.Data.Linq.Link<{0}>", GetPropertyType(property)) : GetPropertyType(property);
      string formatedDefaultValue = (!property.IsComplexType && model.GetModelDescriptor().CanFormatDefaultValue(property.Type, property.DefaultValue)) ? codeProvider.FormatPropertyValue(property.Type, property.DefaultValue) : null; 
#>

        private <#= propertyDataType #> _<#= property.Name #><# if (formatedDefaultValue != null) {#> = <#= formatedDefaultValue #><# } #>;
<#
    }
#>
        #pragma warning restore 0649
<#

    bool serializing = false;
    // Class navigation fields
    foreach (LinqRelationProperty relationProperty in cls.RelationProperties) {
      if (relationProperty.Generate && ((LinqAssociation)relationProperty.Association).IsGenerate) {
        string relationCollectionDataType;

        if (relationProperty.Multiplicity == Multiplicity.Many) { 
          serializing = true;
          relationCollectionDataType = "EntitySet";
        }
        else
          relationCollectionDataType = "EntityRef";
#>

        private <#= relationCollectionDataType #><<#= GetRelationPropertyType(relationProperty) #>> _<#= relationProperty.Name #>;
<#
      }
    } 

    // if serialization
    if (model.SerializationMode != LinqSerializationMode.None && serializing) {
#>

        private bool serializing;
<#
    }

    // extensibility method definitions
    GenerateExtensibilityMethodDefinitions(cls);

    // class constructor
#>

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= codeProvider.GetValidIdentifier(cls.Name) #> constructor in the schema.
        /// </summary>
<#
      }
#>
        public <#= codeProvider.GetValidIdentifier(cls.Name) #>()
        {
<#
    if (model.SerializationMode != LinqSerializationMode.None) { #>
            this.Initialize();
<#
    }
    else {
           foreach (LinqProperty property in cls.Properties) {
             if (property.IsComplexType) {
#>
            this._<#= property.Name #> = new <#= GetPropertyType(property) #>();
<#
             }
           }

           foreach (LinqRelationProperty relationProperty in cls.RelationProperties) {
             if (relationProperty.Generate && ((LinqAssociation)relationProperty.Association).IsGenerate) {
               string relationClassName = GetRelationPropertyType(relationProperty);
               if (relationProperty.Multiplicity == Multiplicity.Many) {
#>
            this._<#=  relationProperty.Name#> = new EntitySet<<#= relationClassName #>>(new Action<<#= relationClassName #>>(this.attach_<#= relationProperty.Name #>), new Action<<#= relationClassName #>>(this.detach_<#= relationProperty.Name #>));
<#
               } else {
#>
            this._<#=  relationProperty.Name#>  = default(EntityRef<<#= relationClassName #>>);
<#
               }
             }
           }

          if (cls.BaseInheritance != null && cls.BaseInheritance.Type == InheritanceType.TPH && cls.BaseInheritance.DiscriminatorProperty != null && cls.BaseInheritance.DerivedClassDiscriminatorValue != null) {
              string formatedValue = cls.BaseInheritance.DerivedClassDiscriminatorValue != null ? codeProvider.FormatPropertyValue(cls.BaseInheritance.DiscriminatorProperty.Type, cls.BaseInheritance.DerivedClassDiscriminatorValue) : null;
            if (formatedValue != null) {
#>
            <#= codeProvider.GetValidIdentifier(cls.BaseInheritance.DiscriminatorProperty.Name) #> = <#= formatedValue #>;
<#
            }
          }
#>
            OnCreated();
<#
         }
#>
        }
<#
    // Class properties
    foreach (LinqProperty property in cls.Properties ) {
      propertyCounter++;
      GenerateProperty(property, propertyCounter, hasPrimaryKey);
    }

    // Class navigation properties  
    foreach (LinqRelationProperty relationProperty in cls.RelationProperties) {
      if (relationProperty.Generate && ((LinqAssociation)relationProperty.Association).IsGenerate) {
        if (relationProperty.Multiplicity == Multiplicity.Many || !relationProperty.OppositeRelationProperty.Generate) 
          propertyCounter ++;
        GenerateRelationProperty(relationProperty, propertyCounter, hasPrimaryKey);
      }
    }

    // ICloneable
    if (ImplementCloneable)
      GenerateICloneable(cls);

    if (implementPropertyChanging) {
#>
   
<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for PropertyChanging event in the schema.
        /// </summary>
<#
      }
#>
        public event PropertyChangingEventHandler PropertyChanging;

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for PropertyChanged event in the schema.
        /// </summary>
<#
      }
#>
        public event PropertyChangedEventHandler PropertyChanged;

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for SendPropertyChanging method in the schema.
        /// </summary>
<#
      }
#>
        protected virtual void SendPropertyChanging()
        {
		        var handler = this.PropertyChanging;
            if (handler != null)
                handler(this, emptyChangingEventArgs);
        }

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for SendPropertyChanging method in the schema.
        /// </summary>
<#
      }
#>
        protected virtual void SendPropertyChanging(System.String propertyName) 
        {    
		        var handler = this.PropertyChanging;
            if (handler != null)
                handler(this, new PropertyChangingEventArgs(propertyName));
        }

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for SendPropertyChanged method in the schema.
        /// </summary>
<#
      }
#>
        protected virtual void SendPropertyChanged(System.String propertyName)
        {    
		        var handler = this.PropertyChanged;
            if (handler != null)
                handler(this, new PropertyChangedEventArgs(propertyName));
        }
<#
    }

    // attach and detach child navigation properties
    GenerateAttachAndDetachChildNavigationProperties(cls, hasPrimaryKey);

     // Serialization
    if (model.SerializationMode != LinqSerializationMode.None)
      GenerateSerializationMethods(cls, hasPrimaryKey);
#>
    }
<#
      if (FilePerClass) {
#>

}
<#
        output.PopOutputRedirection();
      }
    
    } // End of class generation

    if (!FilePerClass) {
#>

}
<#
    }
  } // End of namespace generation

  //------------------------------------------------------------------------------
  // Complex Type class generation
  //------------------------------------------------------------------------------
  var typeNamespaces = from type in model.ComplexTypes.Cast<ComplexType>()
    let nspName = !String.IsNullOrEmpty(type.Namespace) ? codeProvider.GetValidIdentifier(type.Namespace) : namespaceName
    group type by nspName;

  foreach (var _namespace in typeNamespaces) {
    if (!FilePerClass) {
#>

namespace <#= _namespace.Key #>
{
<#
    }
    foreach (LinqComplexType type in _namespace) {
      if (FilePerClass) {
        string rootFileName = ModelNameAsFilesPrefix ? baseFileName + "." + type.Name : type.Name;
        if (GeneratePartialClass) {
          output.Extension = ".cs";
          output.PushOutputRedirection(EntitiesOutput, "", rootFileName, OverwriteMode.None);
          GenerateFileHeader(false);
#>

namespace <#= _namespace.Key #>
{

    <#= codeProvider.FormatClassAccess(type.Access) #> partial class <#= codeProvider.GetValidIdentifier(type.Name) #>
    {
    }
}
<#
          output.PopOutputRedirection();
        }

        output.Extension = ".cs";
        if (GeneratePartialClass)
          output.PushOutputRedirection(EntitiesOutput, rootFileName, rootFileName + ".Generated");
        else
          output.PushOutputRedirection(EntitiesOutput, rootFileName);
        GenerateFileHeader(true);
#>

namespace <#= _namespace.Key #>
{
<#
    }

    int propertyCounter = 0;
    GenerateDocumentation(type.Documentation, type.FullName); 
    if (model.SerializationMode != LinqSerializationMode.None) {
#>
    [DataContract(IsReference = true)]
<#
    }
    foreach(AttributeValue attribute in type.Attributes) {
      output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);     
#>
    <#= codeProvider.FormatAttributeValue(attribute) #>
<#
    }
#>
    <#= codeProvider.FormatClassAccess(type.Access) #> partial class <#= codeProvider.GetValidIdentifier(type.Name) #>: INotifyPropertyChanging, INotifyPropertyChanged<# if (ImplementCloneable) { #>, ICloneable<# } #>
    {

        private static PropertyChangingEventArgs emptyChangingEventArgs = new PropertyChangingEventArgs(System.String.Empty);
<#
#>
        #pragma warning disable 0649
<#

    // type fields
    foreach (LinqProperty property in type.Properties ) {
      string propertyDataType = string.Empty;
      if (property.IsComplexType)
        propertyDataType = GetPropertyType(property);
      else
        propertyDataType = property.DelayLoaded ? string.Format("Devart.Data.Linq.Link<{0}>", GetPropertyType(property)) : GetPropertyType(property);
      string formatedDefaultValue = (!property.IsComplexType && model.GetModelDescriptor().CanFormatDefaultValue(property.Type, property.DefaultValue)) ? codeProvider.FormatPropertyValue(property.Type, property.DefaultValue) : null; 
#>

        private <#= propertyDataType #> _<#= property.Name #><# if (formatedDefaultValue != null) {#> = <#= formatedDefaultValue #><# } #>;
<#
    }
#>
        #pragma warning restore 0649
<#

    GenerateExtensibilityMethodDefinitions(type);
    // type constructor
#>

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= codeProvider.GetValidIdentifier(type.Name) #> constructor in the schema.
        /// </summary>
<#
      }
#>
        public <#= codeProvider.GetValidIdentifier(type.Name) #>()
        {
<#
    foreach (LinqProperty property in type.Properties) {
      if (property.IsComplexType) {
#>
            this._<#= property.Name #> = new <#= codeProvider.GetValidIdentifier(property.Type.ToString()) #>();
<#
      }
    }
#>
            OnCreated();
        }
<#
    // properties
    foreach (LinqProperty property in type.Properties ) {
      propertyCounter++;
      GenerateProperty(property, propertyCounter, true);
    }

    // ICloneable
    if (ImplementCloneable)
      GenerateICloneable(type);
#>
   
<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for PropertyChanging event in the schema.
        /// </summary>
<#
      }
#>
        public event PropertyChangingEventHandler PropertyChanging;

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for PropertyChanged event in the schema.
        /// </summary>
<#
      }
#>
        public event PropertyChangedEventHandler PropertyChanged;

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for SendPropertyChanging method in the schema.
        /// </summary>
<#
      }
#>
        protected virtual void SendPropertyChanging()
        {
		        var handler = this.PropertyChanging;
            if (handler != null)
                handler(this, emptyChangingEventArgs);
        }

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for SendPropertyChanging method in the schema.
        /// </summary>
<#
      }
#>
        protected virtual void SendPropertyChanging(System.String propertyName) 
        {    
		        var handler = this.PropertyChanging;
            if (handler != null)
                handler(this, new PropertyChangingEventArgs(propertyName));
        }

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for SendPropertyChanged method in the schema.
        /// </summary>
<#
      }
#>
        protected virtual void SendPropertyChanged(System.String propertyName)
        {    
		        var handler = this.PropertyChanged;
            if (handler != null)
                handler(this, new PropertyChangedEventArgs(propertyName));
        }
<#

     // Serialization
    if (model.SerializationMode != LinqSerializationMode.None) {
#>
        private void Initialize()
        {
            OnCreated();
        }

<#
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for OnDeserializing method in the schema.
        /// </summary>
<#
      }
#>
        [OnDeserializing()]
        [System.ComponentModel.EditorBrowsableAttribute(EditorBrowsableState.Never)]
        public void OnDeserializing(StreamingContext context)
        {
          this.Initialize();
        }
<#  } #>
    }
<#
      if (FilePerClass) {
#>

}
<#
        output.PopOutputRedirection();
      }
    
    } // End of complex type generation

    if (!FilePerClass) {
#>

}
<#
    }
  } // End of namespace generation

  //------------------------------------------------------------------------------
  // Enum Type class generation
  //------------------------------------------------------------------------------
  var enumTypeNamespaces = from type in model.EnumTypes.Where(e => !e.IsExternal).Cast<LinqEnumType>()
    let nspaceName = !String.IsNullOrEmpty(type.Namespace) ? codeProvider.GetValidIdentifier(type.Namespace) : namespaceName
    group type by nspaceName;

  foreach (var _namespace in enumTypeNamespaces) {
    if (!FilePerClass) {
#>

namespace <#= _namespace.Key #>
{
<#
    }
    foreach (LinqEnumType enumType in _namespace) {
      if (FilePerClass) {
        output.Extension = ".cs";
        output.PushOutputRedirection(EntitiesOutput, ModelNameAsFilesPrefix ? baseFileName + "." + enumType.Name : enumType.Name);
        GenerateFileHeader(true);
#>

namespace <#= _namespace.Key #>
{
<#
      }
    GenerateDocumentation(enumType.Documentation, enumType.FullName); 
    if (model.SerializationMode != LinqSerializationMode.None) {
#>
    [DataContract()]
<#
    }
    foreach(AttributeValue attribute in enumType.Attributes) {
      output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);     
#>
    <#= codeProvider.FormatAttributeValue(attribute) #>
<#
    }

    if (enumType.IsFlag) {
#>
    [Flags]
<#
    }
#>
    <#= codeProvider.FormatClassAccess(enumType.Access) #> enum <#= codeProvider.GetValidIdentifier(enumType.Name) #> : <#= codeProvider.GetNullableType(false, enumType.UnderlyingType.FullName) #>
    {
<# 
     // enum type members
    if (enumType.Members.Count > 0) {
      foreach (EnumTypeMember member in enumType.Members) {
	    
		  output.Indent++;
        GenerateDocumentation(member.Documentation, member.ParentEnum.Name + "." + member.Name);
	    output.Indent--;

        foreach(AttributeValue attribute in member.Attributes) {
          output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);
#>
        <#= codeProvider.FormatAttributeValue(attribute) #>
<#
        }
		
		if (model.SerializationMode != LinqSerializationMode.None) {
#>
        [EnumMember]
<# 
        }
#>
        <#= codeProvider.GetValidIdentifier(member.Name) #><# if (member.Value != null) { #> = <#= member.Value.ToString() #><# } #><# if (member != enumType.Members.Last()) { #>,<# } #>
<#       
      }
    } // End of enum type members generation 
#>

    }
<#
      if (FilePerClass) {
#>

}
<#
        output.PopOutputRedirection();
      }
    
    } // End of enum type generation

    if (!FilePerClass) {
#>

}
<#
    }
  } // End of namespace generation
  output.PopOutputRedirection();

  if (model.Settings.MappingMode == LinqModelMappingMode.File) {
    output.Extension = ".xml";
    output.PushOutputRedirection(ContextOutput, model.FileName, BuildAction.EmbeddedResource, CopyToOutputDirectory.DoNotCopy);
#>
<#= ((EntityDeveloper.Linq.Serialization.LinqModelSerializer)model.GetModelSerializer()).GetXmlMappingText() #>
<#
    output.PopOutputRedirection();
  }

// End of generation
#>
<#+
  private string baseFileName = string.Empty;

  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateFileHeader(bool generateWarning)
  // Comments and namespaces for each generated file.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateFileHeader(bool generateWarning) {
#>
<#+ 
   if (generateWarning) {
#>
//------------------------------------------------------------------------------
// This is auto-generated code.
//------------------------------------------------------------------------------
// This code was generated by Entity Developer tool using LinqConnect template.
// <#= String.IsNullOrEmpty(HeaderTimestampVersionControlTag) ? "Code is generated on: " + DateTime.Now : HeaderTimestampVersionControlTag #>
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//------------------------------------------------------------------------------

<#+
   }
#>
using System;
using Devart.Data.Linq;
using Devart.Data.Linq.Mapping;
using System.Data;
using System.ComponentModel;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
<#+
    if (model.SerializationMode != LinqSerializationMode.None) {
#>
using System.Runtime.Serialization;
<#+
    }
    if (model.Settings.MappingMode == LinqModelMappingMode.File) {
#>
using System.Xml;
using System.IO;
<#+
    }
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateContextFileHeader()
  // Comments and namespaces for context generated file.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateContextFileHeader() {
#>
//------------------------------------------------------------------------------
// This is auto-generated code.
//------------------------------------------------------------------------------
// This code was generated by Entity Developer tool using LinqConnect template.
// <#= String.IsNullOrEmpty(HeaderTimestampVersionControlTag) ? "Code is generated on: " + DateTime.Now : HeaderTimestampVersionControlTag #>
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//------------------------------------------------------------------------------

using System;
using Devart.Data.Linq;
using Devart.Data.Linq.Mapping;
using System.Data;
using System.ComponentModel;
using System.Collections.Generic;
using System.Reflection;
using System.Linq;
using System.Linq.Expressions;
<#+
    if (model.SerializationMode != LinqSerializationMode.None) {
#>
using System.Runtime.Serialization;
<#+
    }
    if (model.Settings.MappingMode == LinqModelMappingMode.File) {
#>
using System.Xml;
using System.IO;
<#+
    }
    if (!string.IsNullOrEmpty(model.ContextNamespace) && model.ContextNamespace != model.GetDefaultNamespace() &&
       (model.Classes.Any(c => string.IsNullOrEmpty(c.Namespace)) || model.ComplexTypes.Any(c => string.IsNullOrEmpty(c.Namespace)) || model.EnumTypes.Any(c => !c.IsExternal && string.IsNullOrEmpty(c.Namespace)))) {
#>
using <#= codeProvider.GetValidIdentifier(model.GetDefaultNamespace()) #>;
<#+
    }
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateContextUpdatesMethods()
  // Insert<class.Name>, Update<class.Name>, Delete<class.Name> partial methods generation.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateContextUpdatesMethods() { 

    // Class properties of context
    foreach (LinqClass cls in model.Classes) { 
      if (!string.IsNullOrEmpty(cls.Source) && cls.AllProperties.Any(p => p.PrimaryKey)) {
        if (cls.InsertMethodMapping.Method == null) {
#>
<#+
      if (GenerateDummyComments) {
#>
        
        /// <summary>
        /// There are no comments for Insert<#= cls.Name #> method in the schema.
        /// </summary>
<#+
      }
#>
        partial void Insert<#= cls.Name #>(<#= GetCodeElementReference(cls) #> instance);
<#+
        }
        if (cls.UpdateMethodMapping.Method == null) {
#>
<#+
      if (GenerateDummyComments) {
#>

        /// <summary>
        /// There are no comments for Update<#= cls.Name #> method in the schema.
        /// </summary>
<#+
      }
#>
        partial void Update<#= cls.Name #>(<#= GetCodeElementReference(cls) #> instance);
<#+
        } 
        if (cls.DeleteMethodMapping.Method == null) {
#>
<#+
      if (GenerateDummyComments) {
#>

        /// <summary>
        /// There are no comments for Delete<#= cls.Name #> method in the schema.
        /// </summary>
<#+
      }
#>
        partial void Delete<#= cls.Name #>(<#= GetCodeElementReference(cls) #> instance);
<#+
        }
      }
    }
  } 
#>
<#+ 
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateContextConstructors()
  // DataContext constructors generation.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateContextConstructors() {

        bool appConfig = model.Settings.ConnectionStringInAppConfig && !String.IsNullOrEmpty(model.Settings.AppConnectionStringName);
#>

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= model.Name #> constructor in the schema.
        /// </summary>
<#+
      }
#>
        public <#= model.Name #>() :
<#+     
        if (appConfig) {
#>
        base(GetConnectionString("<#= model.Settings.AppConnectionStringName #>"), <#+ if (model.Settings.MappingMode != LinqModelMappingMode.Attributes) { #>GetMappingSource()<#+ } else { #>mappingSource<#+ } #>)
<#+
        }
        else {
#>
        base(@"<#= model.FormatConnectionString(ModelLanguage.CS) #>", <#+ if (model.Settings.MappingMode != LinqModelMappingMode.Attributes) { #>GetMappingSource()<#+ } else { #>mappingSource<#+ } #>)
<#+
        }
#>
        {
            OnCreated();
        }

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= model.Name #> constructor in the schema.
        /// </summary>
<#+
      }
#>
        public <#= model.Name #>(MappingSource mappingSource) :
<#+     
        if (appConfig) {
#>
        base(GetConnectionString("<#= model.Settings.AppConnectionStringName #>"), mappingSource)
<#+
        }
        else {
#>
        base(@"<#= model.FormatConnectionString(ModelLanguage.CS) #>", mappingSource)
<#+
        }
#>
        {
            OnCreated();
        }
<#+
        if (model.Settings.MappingMode != LinqModelMappingMode.Attributes) {
#>
  
        private static MappingSource GetMappingSource() 
        {
            if (DefaultXmlMappingProvider.DefaultSource == null)
                throw new InvalidOperationException("You should use the constructor with XmlMappingSource parameter");
            else
                return DefaultXmlMappingProvider.DefaultSource;
        }
<#+
        }
        if (appConfig) {
 #>

        private static string GetConnectionString(string connectionStringName)
        {
            System.Configuration.ConnectionStringSettings connectionStringSettings = System.Configuration.ConfigurationManager.ConnectionStrings[connectionStringName];
            if (connectionStringSettings == null)
                throw new InvalidOperationException("Connection string \"" + connectionStringName +"\" could not be found in the configuration file.");
            return connectionStringSettings.ConnectionString;
        }
<#+      
        }
#>

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= model.Name #> constructor in the schema.
        /// </summary>
<#+
      }
#>
        public <#= model.Name #>(string connection) :
            base(connection, <#+ if (model.Settings.MappingMode != LinqModelMappingMode.Attributes) { #>GetMappingSource()<#+ } else { #>mappingSource<#+ } #>)
        {
          OnCreated();
        }

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= model.Name #> constructor in the schema.
        /// </summary>
<#+
      }
#>
        public <#= model.Name #>(System.Data.IDbConnection connection) :
            base(connection, <#+ if (model.Settings.MappingMode != LinqModelMappingMode.Attributes) { #>GetMappingSource()<#+ } else { #>mappingSource<#+ } #>)
        {
          OnCreated();
        }

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= model.Name #> constructor in the schema.
        /// </summary>
<#+
      }
#>
        public <#= model.Name #>(string connection, MappingSource mappingSource) :
            base(connection, mappingSource)
        {
          OnCreated();
        }

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= model.Name #> constructor in the schema.
        /// </summary>
<#+
      }
#>
        public <#= model.Name #>(System.Data.IDbConnection connection, MappingSource mappingSource) :
            base(connection, mappingSource)
        {
          OnCreated();
        }
<#+
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateContextObjectServices()
  // Class properties of DataContext generation.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateContextObjectServices() {

    // class properties of context
    foreach (LinqClass cls in model.Classes) {
      if (cls.BaseInheritance == null) {
#>

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= codeProvider.GetValidIdentifier(cls.EntitySet) #> property in the schema.
        /// </summary>
<#+
      }
#>
        <#= codeProvider.FormatClassAccess(cls.Access) #> Devart.Data.Linq.Table<<#= GetCodeElementReference(cls) #>> <#= codeProvider.GetValidIdentifier(cls.EntitySet) #>
        {
            get
            {
                return this.GetTable<<#= GetCodeElementReference(cls) #>>();
            }
        }
<#+
      }
    }
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateContextUpdateClassMethod(LinqClassMethodMapping classMethodMapping, string actionPrefix)
  // <actionPrefix><classMethodMapping.ParentClass.Name> method generation.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateContextUpdateClassMethod(LinqClassMethodMapping classMethodMapping, string actionPrefix) { 

    if (classMethodMapping.Method != null) {
      string classTypeReference = GetCodeElementReference(classMethodMapping.ParentClass);

#>

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for <#= actionPrefix #><#= classMethodMapping.ParentClass.Name #> method in the schema.
        /// </summary>
<#+
      }
#>
        private void <#= actionPrefix #><#= classMethodMapping.ParentClass.Name #>(<#= classTypeReference #> obj)
        {
<#+
      bool orig = false;
      foreach (LinqClassMethodMappingArgument am in classMethodMapping.ArgumentMappings) {
        if (am.RowVersion != RowVersion.Current) {
          orig = true;
          break;
        }
      }
      if (orig) {
#>
            <#= classTypeReference #> original = (<#= classTypeReference #>)(<#= codeProvider.GetValidIdentifier(codeProvider.GetPluralString(classMethodMapping.ParentClass.Name)) #>.GetOriginalEntityState(obj));
<#+
      }

      foreach (LinqClassMethodMappingArgument am in classMethodMapping.ArgumentMappings) {
        if (am.Parameter.Direction != ParameterDirection.Input) {
#>
            <#= codeProvider.GetNullableType(true, am.Parameter.Type) #> p<#= codeProvider.GetValidIdentifier(am.Parameter.Name) #> = <#+ if (am.Property == null) { #>default(<#= codeProvider.GetNullableType(true, am.Parameter.Type) #>)<#+ } else { #>obj.<#= codeProvider.GetValidIdentifier(am.Property.Name) #><#+ } #>;
<#+
        }
      }

      // Arguments
      List<string> argumentList = new List<string>();
      foreach (LinqClassMethodMappingArgument am in classMethodMapping.ArgumentMappings) {
        if (am.Parameter.Direction != ParameterDirection.Input){
          if (am.Parameter.Direction == ParameterDirection.InputOutput)
            argumentList.Add(string.Format("ref p{0}", codeProvider.GetValidIdentifier(am.Parameter.Name)));
          else
            argumentList.Add(string.Format("out p{0}", codeProvider.GetValidIdentifier(am.Parameter.Name)));
        }
        else {
          if (am.Property == null)
            argumentList.Add(string.Format("default({0})", codeProvider.GetNullableType(true, am.Parameter.Type)));
          else {
            string castPrefix = am.Parameter.Type is EnumType || IsValueType(am.Parameter.Type.ToString()) ? string.Format("({0})", codeProvider.GetNullableType(true, am.Parameter.Type.ToString())) : string.Empty;

            if (am.RowVersion == RowVersion.Current)
              argumentList.Add(string.Format("{0}{1}{2}", castPrefix, "obj.", am.Property));
            else
              argumentList.Add(string.Format("{0}{1}{2}", castPrefix, "original.", am.Property));
          }
        }
      }
      string arguments = codeProvider.Join(", ", argumentList.ToArray());

      // Method execution
      if (classMethodMapping.ReturnProperty != null) {
        string propType;
        if (classMethodMapping.ReturnProperty.Type is ICodeElement)
          propType = GetCodeElementReference((ICodeElement)classMethodMapping.ReturnProperty.Type);
        else 
          propType = codeProvider.GetNullableType(classMethodMapping.ReturnProperty.Nullable, classMethodMapping.ReturnProperty.Type);
#>
            obj.<#= classMethodMapping.ReturnProperty.Name #> = <#+ if (!classMethodMapping.ReturnProperty.Nullable) { #>(<#= propType #>)<#+ } #>this.<#= codeProvider.GetValidIdentifier(classMethodMapping.Method.Name) #>(<#= arguments #>);
<#+
      }
      else {
#>
            this.<#= classMethodMapping.Method.Name #>(<#= arguments #>);
<#+
      } // End of method execution
#>
<#+
      foreach (LinqClassMethodMappingArgument am in classMethodMapping.ArgumentMappings) {
        if (am.Parameter.Direction != ParameterDirection.Input && am.Property != null) {
          string getValueIfNeeded = am.Parameter.Type is EnumType || IsValueType(am.Parameter.Type.ToString()) ? ".GetValueOrDefault()" : "";
#>
            obj.<#= codeProvider.GetValidIdentifier(am.Property.Name) #> = p<#= codeProvider.GetValidIdentifier(am.Parameter.Name) #><#= getValueIfNeeded #>;
<#+
        }
      }
#>
        }
<#+
    }
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateContextMethods()
  // DataContext methods generation.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateContextMethods() {

    foreach (LinqMethod method in model.Methods) {
      List<string> lst = new List<string>();
      foreach (LinqMethodParameter parameter in method.Parameters) {
        string prefix = string.Empty;
        if (model.Settings.MappingMode == LinqModelMappingMode.Attributes)
          prefix = string.Format("[Parameter(Name=\"{0}\", DbType=\"{1}\")] ", parameter.Source, parameter.DbType);
        if (parameter.Direction == ParameterDirection.InputOutput)
          prefix+= "ref ";
        else
          if (parameter.Direction == ParameterDirection.Output)
            prefix+= "out ";

        lst.Add(string.Format("{0}{1} {2}", prefix, codeProvider.GetNullableType(true, parameter.Type), codeProvider.GetValidIdentifier(parameter.Name)));
      }
#>

<#+
      output.Indent++;
      GenerateDocumentation(method.Documentation, method.Name);
      output.Indent--;
      if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) {
#>
        [Function(Name=@"<#= codeProvider.GetQuotedString(method.Source) #>"<#+ if (method.Pipelined || method.MethodType == MethodType.ScalarResult) { #>, IsComposable=true<#+ } #>)]
<#+
        if (method.MethodType == MethodType.MultipleResult) {
          int count = method.Parameters.Count;
          foreach (BaseClass type in (IList)method.ReturnType) {
#>
        [Devart.Data.Linq.Mapping.ResultType(typeof(<#= GetCodeElementReference(type) #>), <#= count++ #>)]
<#+
          }
        }
      }

      string inheritanceModifier = method.InheritanceModifier == MemberInheritanceModifier.None ? "" : " " + codeProvider.FormatMemberInheritanceModifier(method.InheritanceModifier);
      foreach(AttributeValue attribute in method.Attributes) {
        output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);     
#>
        <#= codeProvider.FormatAttributeValue(attribute) #>
<#+
      }
#>
        <#= codeProvider.FormatMemberAccess(method.Access) #><#= inheritanceModifier #> <#= method.MethodType != MethodType.Procedure ? codeProvider.FormatTypeName(method.GetReturnSignature()) : "void" #> <#= codeProvider.GetValidIdentifier(method.Name) #>(<#= codeProvider.Join(", ", lst.ToArray()) #>)
        {
<#+
      List<string> parametersNameList = new List<string>();
      foreach (LinqMethodParameter parameter in method.Parameters)
        if (parameter.Direction == ParameterDirection.Output)
          parametersNameList.Add(String.Format("({0})null", codeProvider.GetNullableType(true, parameter.Type)));
        else
          parametersNameList.Add(codeProvider.GetValidIdentifier(parameter.Name));

        if (method.Pipelined && method.MethodType != MethodType.Procedure && method.MethodType != MethodType.MultipleResult) {
#>
            return this.CreateMethodCallQuery<<#= (method.ReturnType is BaseClass) ? GetCodeElementReference(((BaseClass)method.ReturnType)) : method.ReturnType.ToString() #>>(this, ((MethodInfo)(MethodInfo.GetCurrentMethod()))<#= parametersNameList.Count > 0 ? ", " + string.Join(", ", parametersNameList.ToArray()) : "" #>);
<#+
        } else {
            string result = codeProvider.GetValidIdentifier(method.Name) + "Result";
#>
            IExecuteResult _<#= result #> = this.ExecuteMethodCall(this, ((MethodInfo)(MethodInfo.GetCurrentMethod()))<#= parametersNameList.Count > 0 ? ", " + string.Join(", ", parametersNameList.ToArray()) : "" #>);
<#+
          int count = 0;
          foreach (LinqMethodParameter parameter in method.Parameters) {
            if (parameter.Direction != ParameterDirection.Input) {
#>
            <#= codeProvider.GetValidIdentifier(parameter.Name) #> = ((<#= codeProvider.GetNullableType(true, parameter.Type) #>)(_<#= result #>.GetParameterValue(<#= parameter.ProcedurePosition > 0 ? parameter.ProcedurePosition - 1 : count #>)));
<#+
            }
          count++;
          }
		  if (method.MethodType != MethodType.Procedure) {
#>
            return ((<#= codeProvider.FormatTypeName(method.GetReturnSignature()) #>)(_<#= result #>.ReturnValue));
<#+
          }
        }
#> 
        }
<#+
    } // Context methods
  }
#>
<#+ 
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateExtensibilityMethodDefinitions()
  // Class extensibility method definitions generation.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateExtensibilityMethodDefinitions(BaseClass cls) {
#>
    
        #region Extensibility Method Definitions

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for OnLoaded method in the schema.
        /// </summary>
<#+
      }
#>
        partial void OnLoaded();
<#+
      if (GenerateDummyComments) {
#>

        /// <summary>
        /// There are no comments for OnValidate method in the schema.
        /// </summary>
<#+
      }
#>
        partial void OnValidate(ChangeAction action);
<#+
      if (GenerateDummyComments) {
#>

        /// <summary>
        /// There are no comments for OnCreated method in the schema.
        /// </summary>
<#+
      }
#>
        partial void OnCreated();
<#+
    foreach (LinqProperty property in cls.Properties) {
#> 
<#+
      if (GenerateDummyComments) {
#>

        /// <summary>
        /// There are no comments for On<#= property.Name #>Changing method in the schema.
        /// </summary>
<#+
      }
#>
        partial void On<#= property.Name #>Changing(<#= GetPropertyType(property) #> value);
<#+
      if (GenerateDummyComments) {
#>

        /// <summary>
        /// There are no comments for On<#= property.Name #>Changed method in the schema.
        /// </summary>
<#+
      }
#>
        partial void On<#= property.Name #>Changed();
<#+
    }
#>
        #endregion
<#+
   }
#>
<#+ 
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateICloneable()
  // ICloneable implementation 
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateICloneable(BaseClass baseClass) {
#>
    
        #region ICloneable Members

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for Clone method in the schema.
        /// </summary>
<#+
      }
#>
<#+ 
    if (baseClass is Class && ((Class)baseClass).InheritanceModifier == ClassInheritanceModifier.Abstract) {
#>
        public abstract object Clone();
<#+ 
    }
    else 
    {
#>
        public <#+ if (baseClass is Class && ((Class)baseClass).BaseInheritance != null) { #>override<#+ } else { #>virtual<#+ } #> object Clone()
        {
            <#= codeProvider.GetValidIdentifier(baseClass.Name) #> obj = new <#= codeProvider.GetValidIdentifier(baseClass.Name) #>();
<#+
      List<Property> properties = new List<Property>();
      if (baseClass is Class)
        properties.AddRange(((Class)baseClass).BaseProperties);
      properties.AddRange(baseClass.Properties);

      foreach (Property prop in properties.Where(p => !((LinqProperty)p).ReadOnly)) {
        if (prop.IsComplexType) {
#>
            obj.<#= codeProvider.GetValidIdentifier(prop.Name) #> = (<#= GetPropertyType(prop) #>)<#= codeProvider.GetValidIdentifier(prop.Name) #>.Clone();
<#+
        }
        else {
#>
            obj.<#= codeProvider.GetValidIdentifier(prop.Name) #> = <#= codeProvider.GetValidIdentifier(prop.Name) #>;
<#+
        }
      }
#>
            return obj;
        }
<#+
    }
#>

        #endregion
<#+
   }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateProperty(LinqProperty property, int propertyOrder, bool supportPropertyChanging)
  // Property generation for classes.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateProperty(LinqProperty property, int propertyOrder, bool supportPropertyChanging) {
#>

<#+
    output.Indent++;
    GenerateDocumentation(property.Documentation, property.Name);
    output.Indent--;

    if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) { 
      if (!property.IsComplexType) {
        if (!string.IsNullOrEmpty(property.Source)) {
#>
        [Column(<#+
          if (property.Name != property.Source) {
          #>Name = @"<#= codeProvider.GetQuotedString(property.Source) #>", <#+
          }
        #>Storage = "_<#= property.Name #>"<#+
          if (property.AutoSync != LinqPropertyAutoSync.Never) {
          #>, AutoSync = AutoSync.<#= property.AutoSync #><#+
          }
          if (!property.Nullable) {
          #>, CanBeNull = false<#+
          }
        #>, DbType = "<#= property.ServerDataType #>"<#+
          if (property.AutoGeneratedValue && (property.IdGenerator == null ||
		                                      property.IdGenerator is IdentityGenerator ||
											  (property.IdGenerator is LinqConnectSequenceGenerator && ((LinqConnectSequenceGenerator)property.IdGenerator).IsDbGenerated) ||
											  (property.IdGenerator is LinqConnectCustomGenerator && ((LinqConnectCustomGenerator)property.IdGenerator).IsDbGenerated))) {
          #>, IsDbGenerated = true<#+
          }
          if (property.IsDiscriminator) {
          #>, IsDiscriminator = true<#+
          }
          if (!property.IsComplexParent && property.PrimaryKey) {
          #>, IsPrimaryKey = true<#+
          }
          if (property.IsVersion) {
          #>, IsVersion = true<#+
          }
          if (property.UpdateCheck != LinqUpdateCheck.Always) {
          #>, UpdateCheck = UpdateCheck.<#= property.UpdateCheck #><#+
          }
        #>)]
<#+
        }
        if (property.IdGenerator != null)
          GenerateGeneratorAttribute(property.IdGenerator);
      } else {
#>
        [Devart.Data.Linq.Mapping.ValueTypeProperty()]
<#+
        if (!property.IsComplexParent) {
          List<PropertyMappingValue> specificSources = property.PropertyMapping.GetSpecificSources();
          foreach (PropertyMappingValue specificSource in specificSources) {
            string memberPathPrefix = "";
            foreach (Property prop in specificSource.MappingKey.PropertyPath)
              if (property != prop)
                memberPathPrefix += prop.Name + ".";
#>
        [Devart.Data.Linq.Mapping.Column(Member = "<#= memberPathPrefix + specificSource.Property.Name #>", Name = @"<#= codeProvider.GetQuotedString(specificSource.Column.Name) #>", Storage = "_<#= specificSource.Property.Name #>", DbType = "<#= ((LinqMappingColumnObject)specificSource.Column).DbType #>")]
<#+   
          }
        }
      }
   }

   if (model.SerializationMode != LinqSerializationMode.None) {
#>
        [DataMember(Order=<#= propertyOrder #>)]
<#+
   }
   
   foreach(AttributeValue attribute in property.Attributes) {
     output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);
#>
        <#= codeProvider.FormatAttributeValue(attribute) #>
<#+
   }

   // Generate validation attributes for property
   GeneratePropertyValidationAttributes(property);

   // Generate DisplayName attribute for property
   if (!string.IsNullOrEmpty(property.DisplayName)) { 
#>
        [System.ComponentModel.DisplayName("<#= property.DisplayName #>")]
<#+
   }

   string propAcces = codeProvider.FormatMemberAccess(property.Access);
   string propInheritanceModifier = property.InheritanceModifier == MemberInheritanceModifier.None ? "" : " " + codeProvider.FormatMemberInheritanceModifier(property.InheritanceModifier);
   string propType = GetPropertyType(property);
   string propName = codeProvider.GetValidIdentifier(property.Name);
   string field = (!property.DelayLoaded || property.IsComplexType) ? "_" + property.Name : "_" + property.Name + ".Value";
#>
        <#= propAcces #><#= propInheritanceModifier #> <#= propType #> <#= propName #>
        {
            get
            {
                return this.<#= field #>;
            }
<#+
   if (!property.ReadOnly) {
#>
            set
            {
                if (this.<#= field #> != value)
                {
<#+
     if (!property.IsComplexParent && !string.IsNullOrEmpty(property.ParentClassName)) {
#>
                    if (this._<#= property.ParentClassName #>.HasLoadedOrAssignedValue)
                    {
                        throw new ForeignKeyReferenceAlreadyHasValueException();
                    }

<#+
     }

     if (supportPropertyChanging) {
#>
                    this.On<#= property.Name #>Changing(value);
                    this.SendPropertyChanging();
<#+
     }
#>
                    this.<#= field #> = value;
<#+
     if (supportPropertyChanging) {
#>
                    this.SendPropertyChanged("<#= codeProvider.GetValidIdentifier(property.Name) #>");
                    this.On<#= property.Name #>Changed();
<#+
     }
#>
                }
            }
<#+
   }
#>
        }
<#+
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateGeneratorAttribute(IdGenerator generator)
  // Standart predefine generator attribute generation for property.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateGeneratorAttribute(IdGenerator generator) {
   
    if (generator is IdentityGenerator)
        ; // Mark in ColumnAttribute as [Column(IsDbGenerated=true, IsPrimaryKey = true)] 
    else if (generator is SequenceGenerator) {
#>
        [Devart.Data.Linq.Mapping.SequenceGenerator(Sequence = "<#= ((SequenceGenerator)generator).Sequence #>")]
<#+
    }
    else if (generator is LinqConnectTableHiLoGenerator) {
#>
        [Devart.Data.Linq.Mapping.TableHiLoGenerator(Table = "<#= ((LinqConnectTableHiLoGenerator)generator).Table #>", Column = "<#= ((LinqConnectTableHiLoGenerator)generator).Column #>", MaxLo = <#= ((LinqConnectTableHiLoGenerator)generator).MaxLo #><#+
          if (!string.IsNullOrEmpty(((LinqConnectTableHiLoGenerator)generator).KeyField)) {
          #>, KeyFieldName = "<#= ((LinqConnectTableHiLoGenerator)generator).KeyField #>", KeyFieldValue = "<#= ((LinqConnectTableHiLoGenerator)generator).KeyFieldValue #>"<#+
          }
          #>)]
<#+
    }
    else if (generator is SequenceHiLoGenerator) {
#>
        [Devart.Data.Linq.Mapping.SequenceHiLoGenerator(Sequence = "<#= ((SequenceHiLoGenerator)generator).Sequence #>", MaxLo = <#= ((SequenceHiLoGenerator)generator).MaxLo #>)]
<#+
    }
    else if (generator is GuidGenerator) {
#>
        [Devart.Data.Linq.Mapping.GuidGenerator()]
<#+
    }
    else {
        List<string> lst = new List<string>();
        foreach (string parameterValue in generator.Parameters.Values)
          lst.Add(string.Format("{0}", parameterValue));
#>
        [Devart.Data.Linq.Mapping.CustomGenerator(ClassName = "<#= ((CustomGenerator)generator).Class #>", Parameters = new object[] { <#= codeProvider.Join(", ", lst.ToArray()) #> })]
<#+
    }
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateRelationProperty()
  // Navigation property generation for entity classes.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateRelationProperty(LinqRelationProperty relationProperty, int propertyOrder, bool supportPropertyChanging) { #>

<#+
    
  	output.Indent++;
    GenerateDocumentation(relationProperty.Documentation, relationProperty.Name);
    output.Indent--;

    // Child
    if (relationProperty.Multiplicity == Multiplicity.Many) {

      // Attributes
      if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) {
#>
        [Devart.Data.Linq.Mapping.Association(Name="<#= relationProperty.Association.Name #>", Storage="_<#= relationProperty.Name #>", ThisKey="<#= codeProvider.JoinCollection(",", relationProperty.OppositeRelationProperty.Properties) #>", OtherKey="<#= codeProvider.JoinCollection(",", relationProperty.Properties) #>"<#+
          if (((LinqAssociation)relationProperty.Association).Cardinality == LinqCardinality.ManyToMany) {
            #>, LinkTableName=@"<#= codeProvider.GetQuotedString(((LinqConnectAssociation)relationProperty.Association).JoinTable) #>", LinkThisKey=@"<#= codeProvider.GetQuotedString(codeProvider.JoinCollection(",", ((LinqConnectRelationProperty)relationProperty.OppositeRelationProperty).LinkColumns)) #>"<#+
            #>, LinkOtherKey=@"<#= codeProvider.GetQuotedString(codeProvider.JoinCollection(",", ((LinqConnectRelationProperty)relationProperty).LinkColumns)) #>"<#+
          }
          #><#+
          if (relationProperty.OppositeRelationProperty.Multiplicity != Multiplicity.Many && !string.IsNullOrEmpty(((LinqAssociation)relationProperty.Association).DeleteRule)) {
          #>, DeleteRule="<#= ((LinqAssociation)relationProperty.Association).DeleteRule #>"<#+
          }
          #>)]
<#+
      } // End of attributes generation

      if (model.SerializationMode != LinqSerializationMode.None) {
#>
        [DataMember(Order=<#= propertyOrder #>, EmitDefaultValue=false)]
<#+
      }

      foreach(AttributeValue attribute in relationProperty.Attributes) {
        output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);     
#>
        <#= codeProvider.FormatAttributeValue(attribute) #>
<#+
      }

      // Generate DisplayName attribute for property
      if (!string.IsNullOrEmpty(relationProperty.DisplayName)) { 
#>
        [System.ComponentModel.DisplayName("<#= relationProperty.DisplayName #>")]
<#+
      }

      // Relation property
      string propAccess = codeProvider.FormatRelationPropertyAccess(relationProperty.Access);
      string propInheritanceModifier = relationProperty.InheritanceModifier == MemberInheritanceModifier.None ? "" : " " + codeProvider.FormatMemberInheritanceModifier(relationProperty.InheritanceModifier);
      string propName = codeProvider.GetValidIdentifier(relationProperty.Name);
      string propType = GetRelationPropertyType(relationProperty);
#>
        <#= propAccess #><#= propInheritanceModifier #> EntitySet<<#= propType #>> <#= propName #>
        {
            get
            {
<#+
      if (model.SerializationMode != LinqSerializationMode.None) {
#>
                if ((this.serializing 
                  && (this._<#= relationProperty.Name #>.HasLoadedOrAssignedValues == false) && (this._<#= relationProperty.Name #>.IsDeferred || this._<#= relationProperty.Name #>.Count == 0)))
                {
                    return null;
                }
<#+
      }
#>
                return this._<#= relationProperty.Name #>;
            }
            set
            {
                this._<#= relationProperty.Name #>.Assign(value);
            }
        }
<#+
    }
    // Parent
    else {

      // Attributes
      if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) {
#>
        [Devart.Data.Linq.Mapping.Association(Name="<#= relationProperty.Association.Name #>", Storage="_<#= relationProperty.Name #>", ThisKey="<#= codeProvider.JoinCollection(",", relationProperty.OppositeRelationProperty.Properties) #>", OtherKey="<#= codeProvider.JoinCollection(",", relationProperty.Properties) #>", <#+
          if (relationProperty.OppositeRelationProperty.Multiplicity != Multiplicity.Many && relationProperty.Association.Child == relationProperty) {
          #>IsUnique=true, IsForeignKey=false<#+
          } else {
          #>IsForeignKey=true<#+
          }#><#+
          if (relationProperty.OppositeRelationProperty.Multiplicity != Multiplicity.Many && relationProperty.Association.Child == relationProperty && !string.IsNullOrEmpty(((LinqAssociation)relationProperty.Association).DeleteRule)) {
          #>, DeleteRule="<#= ((LinqAssociation)relationProperty.Association).DeleteRule #>"<#+
          }
          #><#+
          if (((LinqAssociation)relationProperty.Association).DeleteOnNull && (((LinqAssociation)relationProperty.Association).Cardinality == LinqCardinality.OneToMany || relationProperty.Association.Parent == relationProperty)) {
            #>, DeleteOnNull=true<#+
          }
          #>)]
<#+
      } // End of attributes generation

      if (model.SerializationMode != LinqSerializationMode.None && (!relationProperty.OppositeRelationProperty.Generate || (relationProperty.OppositeRelationProperty.Multiplicity != Multiplicity.Many && relationProperty.Association.Child == relationProperty))) {
#>
        [DataMember(Order=<#= propertyOrder #>, EmitDefaultValue=false)]
<#+     
       }

	   foreach(AttributeValue attribute in relationProperty.Attributes) {
        output.AddReference(attribute.Constructor.AttributeType.Assembly.FromGAC ? attribute.Constructor.AttributeType.Assembly.Name : attribute.Constructor.AttributeType.Assembly.Path);     
#>
        <#= codeProvider.FormatAttributeValue(attribute) #>
<#+
      }

      // Generate DisplayName attribute for property
      if (!string.IsNullOrEmpty(relationProperty.DisplayName)) { 
#>
        [System.ComponentModel.DisplayName("<#= relationProperty.DisplayName #>")]
<#+
      }

      // Relation property
      string propAccess = codeProvider.FormatRelationPropertyAccess(relationProperty.Access);
      string propInheritanceModifier = relationProperty.InheritanceModifier == MemberInheritanceModifier.None ? "" : " " + codeProvider.FormatMemberInheritanceModifier(relationProperty.InheritanceModifier);
      string propName = codeProvider.GetValidIdentifier(relationProperty.Name);
      string propType = GetRelationPropertyType(relationProperty);
#>
        <#= propAccess #><#= propInheritanceModifier #> <#= propType #> <#= propName #>
        {
            get
            {
                return this._<#= relationProperty.Name #>.Entity;
            }
            set
            {
                <#= propType #> previousValue = this._<#= relationProperty.Name #>.Entity;
                if ((previousValue != value) || (this._<#= relationProperty.Name #>.HasLoadedOrAssignedValue == false))
                {
<#+
      if (supportPropertyChanging) {
#>
                    this.SendPropertyChanging();
<#+
      }
#>
                    if (previousValue != null)
                    {
                        this._<#= relationProperty.Name #>.Entity = null;
<#+
      if (relationProperty.OppositeRelationProperty.Generate) {
        if (relationProperty.OppositeRelationProperty.Multiplicity == Multiplicity.Many) {
#>
                        previousValue.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #>.Remove(this);
<#+
        } else { #>
                        previousValue.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #> = null;
<#+
        }
      }
#>
                    }
                    this._<#= relationProperty.Name #>.Entity = value;
                    if (value != null)
                    {
<#+
      if (!(relationProperty.OppositeRelationProperty.Multiplicity != Multiplicity.Many && relationProperty.Association.Child == relationProperty)) {
        for (int i = 0; i < relationProperty.Properties.Count; i++)  {
#>
                        this._<#= relationProperty.OppositeRelationProperty.Properties[i] #> = value.<#= relationProperty.Properties[i] #>;
<#+
          }
      }

      if (relationProperty.OppositeRelationProperty.Generate) {
        if (relationProperty.OppositeRelationProperty.Multiplicity == Multiplicity.Many) {
#>
                        value.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #>.Add(this);
<#+  
        }
        else { #>
                        value.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #> = this;
<#+
        }
      }
      if (!(relationProperty.OppositeRelationProperty.Multiplicity != Multiplicity.Many && relationProperty.Association.Child == relationProperty)) {
#>
                    }
                    else
                    {
<#+
        for (int i = 0; i < relationProperty.Properties.Count; i++)  {
#>
                        this._<#= relationProperty.OppositeRelationProperty.Properties[i] #> = default(<#= codeProvider.GetNullableType(relationProperty.OppositeRelationProperty.Properties[i].Nullable, relationProperty.OppositeRelationProperty.Properties[i].Type) #>);
<#+
        }
      }
#>
                    }
<#+
      if (supportPropertyChanging) {
#>
                    this.SendPropertyChanged("<#= codeProvider.GetValidIdentifier(relationProperty.Name) #>");
<#+
      }
#>
                }
            }
        }
<#+
    } // end of Parent
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateAttachAndDetachChildNavigationProperties(LinqClass cls)
  // Attach and detach child navigation properties generation for entity classes.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateAttachAndDetachChildNavigationProperties(LinqClass cls, bool supportPropertyChanging) {

    foreach (LinqRelationProperty relationProperty in cls.RelationProperties) {
      if (relationProperty.Generate && ((LinqAssociation)relationProperty.Association).IsGenerate) {
        if (relationProperty.Multiplicity == Multiplicity.Many) {
#>

        private void attach_<#= relationProperty.Name #>(<#= GetRelationPropertyType(relationProperty) #> entity)
        {
<#+
          if (supportPropertyChanging) {
#>
            this.SendPropertyChanging("<#= relationProperty.Name #>");
<#+
          }
          if (relationProperty.OppositeRelationProperty.Generate) {
            if (relationProperty.OppositeRelationProperty.Multiplicity == Multiplicity.Many) {
#>
            entity.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #>.Add(this);
<#+
            }
            else { 
#>
            entity.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #> = this;
<#+
            }
          }
#>
        }
    
        private void detach_<#= relationProperty.Name #>(<#= GetRelationPropertyType(relationProperty) #> entity)
        {
<#+
          if (supportPropertyChanging) {
#>
            this.SendPropertyChanging("<#= relationProperty.Name #>");
<#+
          }

          if (relationProperty.OppositeRelationProperty.Generate) {
            if (relationProperty.OppositeRelationProperty.Multiplicity == Multiplicity.Many) {
#>
            entity.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #>.Remove(this);
<#+
            }
            else { 
#>
            entity.<#= codeProvider.GetValidIdentifier(relationProperty.OppositeRelationProperty.Name) #> = null;
<#+
            }
          }
#>
        }
<#+
        }
      }
    }
  }
#>
<#+ 
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateSerializationMethods(LinqClass cls, bool supportPropertyChanging)
  // Initialize, OnDeserializing and OnSerialized generation for entity classes.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateSerializationMethods(LinqClass cls, bool supportPropertyChanging) {
#>

        private void Initialize()
        {
<#+

    bool serializing = false;
   // initialize complex properties
    foreach (LinqProperty property in cls.Properties) {
      if (property.IsComplexType) {
#>
            this._<#= property.Name #> = new <#= GetPropertyType(property) #>();
<#+
      }
    }

    // initialize navigation properties
    foreach (LinqRelationProperty relationProperty in cls.RelationProperties) {
      if (relationProperty.Generate && ((LinqAssociation)relationProperty.Association).IsGenerate) {
        string relationType = GetRelationPropertyType(relationProperty);
        if (relationProperty.Multiplicity == Multiplicity.Many) {
          serializing = true;
#>
            this._<#= relationProperty.Name #> = new EntitySet<<#= relationType #>>(new Action<<#= relationType #>>(this.attach_<#= relationProperty.Name #>), new Action<<#= relationType #>>(this.detach_<#= relationProperty.Name #>));
<#+
        } else {
#>
            this._<#= relationProperty.Name #> = default(EntityRef<<#= relationType #>>);
<#+
        }
      }
    }

    if (cls.BaseInheritance != null && cls.BaseInheritance.Type == InheritanceType.TPH && cls.BaseInheritance.DiscriminatorProperty != null && cls.BaseInheritance.DerivedClassDiscriminatorValue != null) {
      string formatedValue = cls.BaseInheritance.DerivedClassDiscriminatorValue != null ? codeProvider.FormatPropertyValue(cls.BaseInheritance.DiscriminatorProperty.Type, cls.BaseInheritance.DerivedClassDiscriminatorValue) : null;
      if (formatedValue != null) {
#>
            <#= codeProvider.GetValidIdentifier(cls.BaseInheritance.DiscriminatorProperty.Name) #> = <#= formatedValue #>;
<#+
      }
    }

    if (supportPropertyChanging) {
#>
            OnCreated();
<#+
    }
#>
        }
    
<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for OnDeserializing method in the schema.
        /// </summary>
<#+
      }
#>
        [OnDeserializing()]
        [System.ComponentModel.EditorBrowsableAttribute(EditorBrowsableState.Never)]
        public void OnDeserializing(StreamingContext context)
        {
          this.Initialize();
        }
<#+
    if (serializing) {
#>

<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for OnSerializing method in the schema.
        /// </summary>
<#+
      }
#>
        [OnSerializing()]
        [System.ComponentModel.EditorBrowsableAttribute(EditorBrowsableState.Never)]
        public void OnSerializing(StreamingContext context)
        {
          this.serializing = true;
        }
    
<#+
      if (GenerateDummyComments) {
#>
        /// <summary>
        /// There are no comments for OnSerialized method in the schema.
        /// </summary>
<#+
      }
#>
        [OnSerialized()]
        [System.ComponentModel.EditorBrowsableAttribute(EditorBrowsableState.Never)]
        public void OnSerialized(StreamingContext context)
        {
          this.serializing = false;
        }
<#+
    }
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateMethodColumn(LinqProperty column)
  // Column generation for method.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateMethodColumn(LinqProperty column, int columnCounter) {
#>

<#+
    output.Indent++;
    GenerateDocumentation(column.Documentation, column.Name);
    output.Indent--;
    if (model.Settings.MappingMode == LinqModelMappingMode.Attributes) {
#>
        [Column(Storage="_<#= column.Name #>", DbType="<#= column.ServerDataType #>")]
<#+

      if (model.SerializationMode != LinqSerializationMode.None) {
#>
        [DataMember(Order=<#= columnCounter #>)]
<#+
      }
    }
#>
        public <#= GetPropertyType(column) #> <#= codeProvider.GetValidIdentifier(column.Name) #>
        {
            get
            {
                return this._<#= column.Name #>;
            }
            set
            {
                if (Object.Equals(this._<#= column.Name #>, value) == false)
                {
                    this._<#= column.Name #> = value;
                }
            }
        }
<#+
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Method GenerateDocumentation()
  // Documentation comments generation for classes, properties and methods.
  //
  //////////////////////////////////////////////////////////////////////////////////
  private void GenerateDocumentation(Documentation doc, string name) {
#>

    /// <summary>
<#+
    if (!string.IsNullOrEmpty(doc.Summary)) {
      foreach (string str in doc.Summary.Split('\n')) {
#>
    /// <#= str.TrimEnd('\r') #>
<#+
      }
    }
    else {
#>
    /// There are no comments for <#= name #> in the schema.
<#+
    }
#>
    /// </summary>
<#+
    if (!string.IsNullOrEmpty(doc.LongDescription)) {
#>
    /// <LongDescription>
<#+
      foreach (string str in doc.LongDescription.Split('\n')) {
#>
    /// <#= str.TrimEnd('\r') #>
<#+
      }
#>
    /// </LongDescription>
<#+
    }
  }
#>
<#+
  //////////////////////////////////////////////////////////////////////////////////
  //
  // Utility methods
  //
  //////////////////////////////////////////////////////////////////////////////////
  // Method GetCodeElementReference
  private string GetCodeElementReference(ICodeElement element) {

    if (!string.IsNullOrEmpty(element.Namespace) && element.Namespace != model.GetDefaultNamespace())
      return codeProvider.GetValidIdentifier(element.Namespace) + "." + codeProvider.GetValidIdentifier(element.Name);
    return codeProvider.GetValidIdentifier(element.Name);
  }

  // Method GetPropertyType
  private string GetPropertyType(Property prop) {
    string propertyDataType = string.Empty;
    if (prop.Type is ICodeElement) {
      string nspace = !string.IsNullOrEmpty(((ICodeElement)prop.Type).Namespace) ? ((ICodeElement)prop.Type).Namespace : model.GetDefaultNamespace();
      propertyDataType = codeProvider.GetValidIdentifier(((ICodeElement)prop.Type).Name);
      if (nspace != prop.ParentClass.NamespaceUsed)
        propertyDataType = codeProvider.GetValidIdentifier(nspace) + "." + propertyDataType;
      if (prop.IsEnumType && prop.Nullable)
        propertyDataType = codeProvider.FormatNullable(propertyDataType);
    }
    else
      propertyDataType = codeProvider.GetNullableType(prop.Nullable, prop.Type);
    return propertyDataType;
  }
  
  // Method GetRelationPropertyType
  private string GetRelationPropertyType(RelationProperty relationProperty) {

    string relationType = codeProvider.GetValidIdentifier(relationProperty.RelationClass.Name);
    if (relationProperty.RelationClass.NamespaceUsed != relationProperty.ParentClass.NamespaceUsed)
      relationType = codeProvider.GetValidIdentifier(relationProperty.RelationClass.NamespaceUsed) + "." + relationType;
    return relationType;
  }

  // Method IsValueType()
  private bool IsValueType(string propType) {

      Type t = Type.GetType(propType);
      return (t == null) ? false : t.IsValueType;
  }

  // Method GetVariableName()
  private string GetVariableName(string name) {

    return codeProvider.GetValidIdentifier(name.Substring(0, 1).ToLower()+ name.Substring(1));
  }
#>